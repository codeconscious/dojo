module Collections
(* References:
   - https://vgaltes.com/post/sequences-in-fsharp/
   - https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html
*)

(* About `fold`:
    Corresponds to the `Aggregate` method in C# and `reduce` in other languages.
*)
module Fold =
    type Charge =
        | In of int
        | Out of int

    let inputs = [In 1; Out 2; In 3]

    // `||>`: Passes the tuple of 2 arguments on the left side to the function on the right side.
    let foldIt start = (start, inputs) ||> Seq.fold (fun acc charge ->
        match charge with
        | In i -> acc + i
        | Out o -> acc - o)

    type CoinToss = Head | Tails

    let group1 = [Tails; Head; Tails]
    let group2 = [Tails; Head; Head]

    // `|||>`: Passes the tuple of 3 arguments on the left side to the function on the right side!
    let foldIt2 start = (start, group1, group2) |||> Seq.fold2 (fun acc a b ->
        match (a, b) with
        | Head, Head -> acc + 1
        | Tails, Tails -> acc + 1
        | _ -> acc - 1)

(* About `unfold`:
    Returns a sequence that contains the elements generated by the given computation.
    The given initial state argument is passed to the element generator. For each
    IEnumerator elements in the stream are generated on-demand by applying the
    element generator, until a None value is returned by the element generator.
    For Some, it returns a tuple with the next element of the sequence (in this case
    the square) and the next state to be passed to unfold (in this case, the next number).
    Each call to the element generator returns a new residual state.
*)
module Unfold =
    let squareUpTo start max =
        start // Starting value
        |> Seq.unfold(fun i -> if ( i*i > max ) then None
                               else Some(i*i, i + 1))
        |> Seq.toArray
