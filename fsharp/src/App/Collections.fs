module Collections

module Sequences =
    module Choose =
        // https://thesharperdev.com/snippets/fsharp-seq-choose/
        // Seq.choose call the passed-in function and filter for only those cases
        // where the function returns Some(value). The values themselves are returned.
        let ids =
            [Some 1; None; Some 2]
            |> Seq.choose id
        printfn "%A" ids // seq [1; 2]

module Lists =
    let list = List.init 5 (fun index -> index * 2)
    let rndList = let r = System.Random() in List.init 10 (fun x -> r.Next(0, 10))

    List.exists (fun x -> x > 2) [1..5] |> ignore // true
    // Prefer List.tryFind and List.tryFindIndex over the non-`try` versions.
    // Lists are the last parameter to support partial application and pipelining.

module DictionariesAndMap =
    let partsDict = [ "Nuts", 15; "Bolts", 15] |> dict
    let nutsQuantity = partsDict["Nuts"] // 15

    open System.Collections.Generic
    let mutableDict = new Dictionary<string, int>()
    let mutableDict2 = new Dictionary<_,_>()
    mutableDict2["a"] <- 1 // Dictionary type is calcuated here!

    let capitals = ["USA", "Washington D.C."; "Japan", "Tokyo"] |> Map.ofList
    let usa = capitals["USA"]
    let newCapitals =
        capitals
        |> Map.add "Mexico" "Mexico City"
        |> Map.remove "USA"

module Sets =
    let set1 = ["C"; "B"; "A"] |> Set.ofList // [A, B, C]
    let set1b = set1.Remove("F") // No problem!
    let set2 = ["A"; "C"] |> Set.ofList

    let union = set1 + set2
    let distinctToSet1 = set1 - set2 // ["B"]
    let intersect = set1 |> Set.intersect set2
    let isSubset = set1 |> Set.isSubset set2

(* References:
   - https://vgaltes.com/post/sequences-in-fsharp/
   - https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html
*)

(* About `fold`:
    Corresponds to the `Aggregate` method in C# and `reduce` in other languages.
*)
module Fold =
    type Charge =
        | In of int
        | Out of int

    let inputs = [In 1; Out 2; In 3]

    // `||>`: Passes the tuple of 2 arguments on the left side to the function on the right side.
    let foldIt start =
        (start, inputs)
        ||> Seq.fold (fun acc charge ->
            match charge with
            | In i -> acc + i
            | Out o -> acc - o)

    type CoinToss = Head | Tails

    let group1 = [Tails; Head; Tails]
    let group2 = [Tails; Head; Head]

    // `|||>`: Passes the tuple of 3 arguments on the left side to the function on the right side!
    let foldIt2 start =
        (start, group1, group2)
        |||> Seq.fold2 (fun acc a b ->
            match (a, b) with
            | Head, Head -> acc + 1
            | Tails, Tails -> acc + 1
            | _ -> acc - 1)

    let sumNums = (0, [1..5]) ||> List.fold (fun s v -> s + v * v)  // evaluates to 55

(* About `unfold`:
    Returns a sequence that contains the elements generated by the given computation.
    The given initial state argument is passed to the element generator. For each
    IEnumerator elements in the stream are generated on-demand by applying the
    element generator, until a None value is returned by the element generator.
    For Some, it returns a tuple with the next element of the sequence (in this case
    the square) and the next state to be passed to unfold (in this case, the next number).
    Each call to the element generator returns a new residual state.
*)
module Unfold =
    let squareUpTo start max =
        start // Starting value
        |> Seq.unfold(fun i -> if ( i*i > max ) then None
                               else Some(i*i, i + 1))
        |> Seq.toArray

module Functions =
    type Country = { Name: string; Abbreviation: string }
    type Item = { Name: string; Country: Country; Amount: decimal }

    let ja = { Name = "Japan"; Abbreviation = "JA" }
    let us = { Name = "United States"; Abbreviation = "USA" }

    let items = [
        for i in 100m..100m..1000m -> { Name = "Item name"; Country = ja; Amount = i } // Comprehension!
        yield { Name = "Item name"; Country = us; Amount = 500m }
        yield { Name = "Item name"; Country = us; Amount = 333m }
        yield { Name = "Item name"; Country = us; Amount = 111m }
    ]

    let cheapestJaItemsCount =
        items
        |> List.filter (fun i -> i.Country.Abbreviation = "JA")
        |> List.where (fun i -> i.Amount <= 2000m)
        |> List.map (fun i -> i.Amount)
        |> List.length

    let usItems, jaItems = items |> List.partition (fun i -> i.Country.Abbreviation = "US")

    let summary =
        items
        |> List.filter (fun i -> i.Country.Name = "United States")
        |> List.mapi (fun i item -> sprintf "%i. %A" i item.Amount)
        |> String.concat "\n"
